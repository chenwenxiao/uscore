### 练习1

在alloc_proc函数中，添加对应的初始化参数即可。

包括state/pid/runs/kstack/need_resched/parent/mm/context/tf/cr3/flags/name参数。

其中context和tf的含义是上线文和中断帧，用作系统调用或者其他中断调用，在这次的fork中，需要使用tf来使得新建的线程就像是从用户调用系统调用进入内核，而还没有返回的状态，而之后的返回与父函数不一样也与之有关系。而context用作进程的切换，保存现场信息以便切换回来时在使用。

参考：
● context：进程的上下文，用于进程切换（参见switch.S）。在 uCore中，所有的进程在内核中也是相对独立的（例如独立的内核堆栈以及上下文等等）。使用 context 保存寄存器的目的就在于在内核态中能够进行上下文之间的切换。实际利用context进行上下文切换的函数是在kern/process/switch.S中定义switch_to。

● tf：中断帧的指针，总是指向内核栈的某个位置：当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态。当内核需要跳回用户空间时，需要调整中断帧以恢复让进程继续执行的各寄存器值。除此之外，uCore内核允许嵌套中断。因此为了保证嵌套中断发生时tf 总是能够指向当前的trapframe，uCore 在内核栈上维护了 tf 的链，可以参考trap.c::trap函数做进一步的了解。

### 练习2

首先使用alloc_proc分配一块用户信息块
之后为其设置父线程
使用setup_kstack设置内核栈，如果不成功应当删除用户信息块
使用copy_mm为其复制原来的内存，如果不成功应当删除内核栈，并删除用户信息块
之后使用copy_thread拷贝上线文信息
之后为子线程获取唯一的pid，并作hash，添加到proc的list中，记录总线程数+1
在上一行的步骤中，由于	涉及到proc的操作，应当将中断开关关闭再执行，否则可能由于中断而导致proc的不安全，例如在新增proc到proc_list时被调度打断，并切换到另一个proc，这时候会很不安全
之后唤醒子线程，返回对应pid即可，对于子线程则会返回与父线程不同的ret，这是在fork时修改了子线程的栈实现的

pid是唯一的，因为调用了get_pid函数，而这个函数会采取某种遍历的算法，保证返回的pid不与其他线程相同

### 练习3

- 两个，一个是初始线程idleproc，一个是init_main
- 在练习2中描述了，防止被打断，因为这里涉及了proc_list的操作，被打断可能导致冲突。